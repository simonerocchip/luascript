{"slots": {"4": {"name": "atmofueltank_4", "type": {"methods": [], "events": []}}, "-1": {"name": "unit", "type": {"methods": [], "events": []}}, "5": {"name": "slot6", "type": {"methods": [], "events": []}}, "-2": {"name": "system", "type": {"methods": [], "events": []}}, "-3": {"name": "library", "type": {"methods": [], "events": []}}, "0": {"name": "core", "type": {"methods": [], "events": []}}, "1": {"name": "atmofueltank_1", "type": {"methods": [], "events": []}}, "2": {"name": "atmofueltank_2", "type": {"methods": [], "events": []}}, "3": {"name": "atmofueltank_3", "type": {"methods": [], "events": []}}, "6": {"name": "slot7", "type": {"methods": [], "events": []}}, "7": {"name": "slot8", "type": {"methods": [], "events": []}}, "8": {"name": "slot9", "type": {"methods": [], "events": []}}, "9": {"name": "slot10", "type": {"methods": [], "events": []}}, "10": {"name": "slot11", "type": {"methods": [], "events": []}}, "11": {"name": "slot12", "type": {"methods": [], "events": []}}, "12": {"name": "slot13", "type": {"methods": [], "events": []}}, "13": {"name": "slot14", "type": {"methods": [], "events": []}}, "14": {"name": "slot15", "type": {"methods": [], "events": []}}, "15": {"name": "slot16", "type": {"methods": [], "events": []}}, "16": {"name": "slot17", "type": {"methods": [], "events": []}}, "17": {"name": "slot18", "type": {"methods": [], "events": []}}, "18": {"name": "slot19", "type": {"methods": [], "events": []}}, "19": {"name": "slot20", "type": {"methods": [], "events": []}}, "20": {"name": "slot21", "type": {"methods": [], "events": []}}}, "handlers": [{"key": "0", "filter": {"slotKey": "-1", "signature": "start()", "args": []}, "code": "-- category panel display helpers\n_autoconf = {}\n_autoconf.panels = {}\n_autoconf.panels_size = 0\n_autoconf.displayCategoryPanel = function(elements, size, title, type, widgetPerData)\n    widgetPerData = widgetPerData or false -- default to one widget for all data\n    if size > 0 then\n        local panel = system.createWidgetPanel(title)\n        local widget\n        if not widgetPerData then\n            widget = system.createWidget(panel, type)\n        end\n        for i = 1, size do\n            if widgetPerData then\n                widget = system.createWidget(panel, type)\n            end\n            system.addDataToWidget(elements[i].getDataId(), widget)\n        end\n        _autoconf.panels_size = _autoconf.panels_size + 1\n        _autoconf.panels[_autoconf.panels_size] = panel\n    end\nend\n_autoconf.hideCategoryPanels = function()\n    for i=1,_autoconf.panels_size do\n        system.destroyWidgetPanel(_autoconf.panels[i])\n    end\nend\n-- Proxy array to access auto-plugged slots programmatically\n\natmofueltank = {}\natmofueltank[1] = atmofueltank_1\natmofueltank[2] = atmofueltank_2\natmofueltank[3] = atmofueltank_3\natmofueltank[4] = atmofueltank_4\natmofueltank_size = 4\n\nrocketfueltank = {}\nrocketfueltank_size = 0\n\nspacefueltank = {}\nspacefueltank_size = 0\n\nweapon = {}\nweapon_size = 0\n\nradar = {}\nradar_size = 0\n-- End of auto-generated code\nNav = Navigator.new(system, core, unit)\nNav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})\nNav.axisCommandManager:setTargetGroundAltitude(4)\n\n-- element widgets\n-- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.\n_autoconf.displayCategoryPanel(weapon, weapon_size, \"Weapons\", \"weapon\", true)\ncore.show()\n_autoconf.displayCategoryPanel(radar, radar_size, \"Periscope\", \"periscope\")\nplaceRadar = true\nif atmofueltank_size > 0 then\n    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, \"Atmo Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\nif spacefueltank_size > 0 then\n    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, \"Space Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\n_autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, \"Rocket Fuel\", \"fuel_container\")\nif placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels\n    _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n    placeRadar = false\nend\nif antigrav ~= nil then antigrav.show() end\nif warpdrive ~= nil then warpdrive.show() end\nif gyro ~= nil then gyro.show() end\n\n-- freeze the player in he is remote controlling the construct\nif Nav.control.isRemoteControlled() == 1 then\n    system.freeze(1)\nend\n\n-- landing gear\n-- make sure every gears are synchonized with the first\ngearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean\nif gearExtended then\n    Nav.control.extendLandingGears()\nelse\n    Nav.control.retractLandingGears()\nend\n"}, {"key": "1", "filter": {"slotKey": "-1", "signature": "stop()", "args": []}, "code": "_autoconf.hideCategoryPanels()\nif antigrav ~= nil then antigrav.hide() end\nif warpdrive ~= nil then warpdrive.hide() end\nif gyro ~= nil then gyro.hide() end\ncore.hide()\nNav.control.switchOffHeadlights()\n"}, {"key": "2", "filter": {"slotKey": "-2", "signature": "actionStart(left)", "args": [{"value": "left"}]}, "code": "rollInput = rollInput - 1"}, {"key": "3", "filter": {"slotKey": "-2", "signature": "actionStart(backward)", "args": [{"value": "backward"}]}, "code": "pitchInput = pitchInput + 1"}, {"key": "4", "filter": {"slotKey": "-2", "signature": "actionStop(backward)", "args": [{"value": "backward"}]}, "code": "pitchInput = pitchInput - 1"}, {"key": "5", "filter": {"slotKey": "-2", "signature": "actionStart(right)", "args": [{"value": "right"}]}, "code": "rollInput = rollInput + 1"}, {"key": "6", "filter": {"slotKey": "-2", "signature": "actionStop(left)", "args": [{"value": "left"}]}, "code": "rollInput = rollInput + 1"}, {"key": "7", "filter": {"slotKey": "-2", "signature": "actionStart(straferight)", "args": [{"value": "straferight"}]}, "code": "Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)"}, {"key": "8", "filter": {"slotKey": "-2", "signature": "actionStop(right)", "args": [{"value": "right"}]}, "code": "rollInput = rollInput - 1"}, {"key": "9", "filter": {"slotKey": "-2", "signature": "actionStop(strafeleft)", "args": [{"value": "strafeleft"}]}, "code": "Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)"}, {"key": "10", "filter": {"slotKey": "-2", "signature": "actionStart(strafeleft)", "args": [{"value": "strafeleft"}]}, "code": "Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)"}, {"key": "11", "filter": {"slotKey": "-2", "signature": "actionStop(straferight)", "args": [{"value": "straferight"}]}, "code": "Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)"}, {"key": "12", "filter": {"slotKey": "-2", "signature": "actionStop(up)", "args": [{"value": "up"}]}, "code": "Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n"}, {"key": "13", "filter": {"slotKey": "-2", "signature": "actionStart(up)", "args": [{"value": "up"}]}, "code": "Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)\n"}, {"key": "14", "filter": {"slotKey": "-2", "signature": "actionStart(down)", "args": [{"value": "down"}]}, "code": "Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)\n"}, {"key": "15", "filter": {"slotKey": "-2", "signature": "actionStart(groundaltitudeup)", "args": [{"value": "groundaltitudeup"}]}, "code": "Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)"}, {"key": "16", "filter": {"slotKey": "-2", "signature": "actionStop(down)", "args": [{"value": "down"}]}, "code": "Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n"}, {"key": "17", "filter": {"slotKey": "-2", "signature": "actionLoop(groundaltitudeup)", "args": [{"value": "groundaltitudeup"}]}, "code": "Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)"}, {"key": "18", "filter": {"slotKey": "-2", "signature": "actionLoop(groundaltitudedown)", "args": [{"value": "groundaltitudedown"}]}, "code": "Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)"}, {"key": "19", "filter": {"slotKey": "-2", "signature": "actionStart(groundaltitudedown)", "args": [{"value": "groundaltitudedown"}]}, "code": "Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)"}, {"key": "20", "filter": {"slotKey": "-2", "signature": "actionStart(yawright)", "args": [{"value": "yawright"}]}, "code": "yawInput = yawInput - 1"}, {"key": "21", "filter": {"slotKey": "-2", "signature": "actionStart(yawleft)", "args": [{"value": "yawleft"}]}, "code": "yawInput = yawInput + 1"}, {"key": "22", "filter": {"slotKey": "-2", "signature": "actionStop(yawright)", "args": [{"value": "yawright"}]}, "code": "yawInput = yawInput + 1"}, {"key": "23", "filter": {"slotKey": "-2", "signature": "start()", "args": []}, "code": "pitchInput = 0\nrollInput = 0\nyawInput = 0\nbrakeInput = 0\n"}, {"key": "24", "filter": {"slotKey": "-2", "signature": "flush()", "args": []}, "code": "-- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu\n\nlocal pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01\nlocal brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)\nlocal autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01\n\nlocal turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is\nlocal turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\n-- validate params\npitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)\nyawSpeedFactor = math.max(yawSpeedFactor, 0.01)\nrollSpeedFactor = math.max(rollSpeedFactor, 0.01)\ntorqueFactor = math.max(torqueFactor, 0.01)\nbrakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)\nbrakeFlatFactor = math.max(brakeFlatFactor, 0.01)\nautoRollFactor = math.max(autoRollFactor, 0.01)\nturnAssistFactor = math.max(turnAssistFactor, 0.01)\n\n-- final inputs\nlocal finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\nlocal finalRollInput = rollInput + system.getControlDeviceYawInput()\nlocal finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\nlocal finalBrakeInput = brakeInput\n\n-- Axis\nlocal worldVertical = vec3(core.getWorldVertical()) -- along gravity\nlocal constructUp = vec3(core.getConstructWorldOrientationUp())\nlocal constructForward = vec3(core.getConstructWorldOrientationForward())\nlocal constructRight = vec3(core.getConstructWorldOrientationRight())\nlocal constructVelocity = vec3(core.getWorldVelocity())\nlocal constructVelocityDir = vec3(core.getWorldVelocity()):normalize()\nlocal currentRollDeg = getRoll(worldVertical, constructForward, constructRight)\nlocal currentRollDegAbs = math.abs(currentRollDeg)\nlocal currentRollDegSign = utils.sign(currentRollDeg)\n\n-- Rotation\nlocal constructAngularVelocity = vec3(core.getWorldAngularVelocity())\nlocal targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight\n                                + finalRollInput * rollSpeedFactor * constructForward\n                                + finalYawInput * yawSpeedFactor * constructUp\n\n-- In atmosphere?\nif worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then\n    local autoRollRollThreshold = 1.0\n    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling\n    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then\n        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit\n        if (rollPID == nil) then\n            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        rollPID:inject(targetRollDeg - currentRollDeg)\n        local autoRollInput = rollPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward\n    end\n    local turnAssistRollThreshold = 20.0\n    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing\n    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then\n        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range\n        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range\n\n        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)\n        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180\n        local rollVerticalRatio = 0\n        if rescaleRollDegAbs < 90 then\n            rollVerticalRatio = rescaleRollDegAbs / 90\n        elseif rescaleRollDegAbs < 180 then\n            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90\n        end\n\n        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio\n\n        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)\n        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio\n\n        targetAngularVelocity = targetAngularVelocity\n                            + turnAssistPitchInput * constructRight\n                            + turnAssistYawInput * constructUp\n    end\nend\n\n-- Engine commands\nlocal keepCollinearity = 1 -- for easier reading\nlocal dontKeepCollinearity = 0 -- for easier reading\nlocal tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n\n-- Rotation\nlocal angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)\nlocal airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())\nangularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction\nNav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\n-- Brakes\nlocal brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\nNav:setEngineForceCommand('brake', brakeAcceleration)\n\n-- AutoNavigation regroups all the axis command by 'TargetSpeed'\nlocal autoNavigationEngineTags = ''\nlocal autoNavigationAcceleration = vec3()\nlocal autoNavigationUseBrake = false\n\n-- Longitudinal Translation\nlocal longitudinalEngineTags = 'thrust analog longitudinal'\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byThrottle) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\n    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)\nelseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration\n    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop\n        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking\n    then\n        autoNavigationUseBrake = true\n    end\n\nend\n\n-- Lateral Translation\nlocal lateralStrafeEngineTags = 'thrust analog lateral'\nlocal lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)\nif (lateralCommandType == axisCommandType.byThrottle) then\n    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\n    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)\nelseif  (lateralCommandType == axisCommandType.byTargetSpeed) then\n    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration\nend\n\n-- Vertical Translation\nlocal verticalStrafeEngineTags = 'thrust analog vertical'\nlocal verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)\nif (verticalCommandType == axisCommandType.byThrottle) then\n    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\n    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)\nelseif  (verticalCommandType == axisCommandType.byTargetSpeed) then\n    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration\nend\n\n-- Auto Navigation (Cruise Control)\nif (autoNavigationAcceleration:len() > constants.epsilon) then\n    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward\n    then\n        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n    end\n    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\nend\n\n-- Rockets\nNav:setBoosterCommand('rocket_engine')\n"}, {"key": "25", "filter": {"slotKey": "-2", "signature": "actionStart(gear)", "args": [{"value": "gear"}]}, "code": "gearExtended = not gearExtended\nif gearExtended then\n    Nav.control.extendLandingGears()\nelse\n    Nav.control.retractLandingGears()\nend\n"}, {"key": "26", "filter": {"slotKey": "-2", "signature": "update()", "args": []}, "code": "Nav:update()"}, {"key": "27", "filter": {"slotKey": "-2", "signature": "actionStart(light)", "args": [{"value": "light"}]}, "code": "if Nav.control.isAnyHeadlightSwitchedOn() == 1 then\n    Nav.control.switchOffHeadlights()\nelse\n    Nav.control.switchOnHeadlights()\nend\n"}, {"key": "28", "filter": {"slotKey": "-2", "signature": "actionStop(forward)", "args": [{"value": "forward"}]}, "code": "pitchInput = pitchInput + 1"}, {"key": "29", "filter": {"slotKey": "-2", "signature": "actionStart(forward)", "args": [{"value": "forward"}]}, "code": "pitchInput = pitchInput - 1"}, {"key": "30", "filter": {"slotKey": "-2", "signature": "actionLoop(brake)", "args": [{"value": "brake"}]}, "code": "local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n"}, {"key": "31", "filter": {"slotKey": "-2", "signature": "actionStart(booster)", "args": [{"value": "booster"}]}, "code": "Nav:toggleBoosters()"}, {"key": "32", "filter": {"slotKey": "-2", "signature": "actionStart(speedup)", "args": [{"value": "speedup"}]}, "code": "Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)"}, {"key": "33", "filter": {"slotKey": "-2", "signature": "actionStart(stopengines)", "args": [{"value": "stopengines"}]}, "code": "Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)"}, {"key": "34", "filter": {"slotKey": "-2", "signature": "actionLoop(speedup)", "args": [{"value": "speedup"}]}, "code": "Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)"}, {"key": "35", "filter": {"slotKey": "-2", "signature": "actionStart(speeddown)", "args": [{"value": "speeddown"}]}, "code": "Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)"}, {"key": "36", "filter": {"slotKey": "-2", "signature": "actionLoop(speeddown)", "args": [{"value": "speeddown"}]}, "code": "Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)"}, {"key": "37", "filter": {"slotKey": "-2", "signature": "actionStart(warp)", "args": [{"value": "warp"}]}, "code": "if warpdrive ~= nil then warpdrive.activateWarp() end"}, {"key": "38", "filter": {"slotKey": "-2", "signature": "actionStart(antigravity)", "args": [{"value": "antigravity"}]}, "code": "if antigrav ~= nil then antigrav.toggle() end"}, {"key": "39", "filter": {"slotKey": "-2", "signature": "actionStop(yawleft)", "args": [{"value": "yawleft"}]}, "code": "yawInput = yawInput - 1"}, {"key": "40", "filter": {"slotKey": "-2", "signature": "actionStart(brake)", "args": [{"value": "brake"}]}, "code": "brakeInput = brakeInput + 1\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n"}, {"key": "41", "filter": {"slotKey": "-2", "signature": "actionStop(brake)", "args": [{"value": "brake"}]}, "code": "brakeInput = brakeInput - 1"}], "methods": [], "events": []}